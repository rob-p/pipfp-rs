{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>pipfp-rs</code>: A Rust implementation of piPFP for measuring the growth of sequence collections","text":"<p><code>pipfp-rs</code> is a Rust implementation of <code>pipfp</code><sup>2</sup>. It is a program to compute a quantity called \\(\\pi_{w,p}\\), which measures the substring complexity of a sequence or  sequence collection. By looking at how \\(\\pi_{w,p}\\) changes as new sequences are added to the collection, one can infer how much novel sequence is appearing, or how redundant the newly added sequences are compared to what is already present in the collection.  The parameters \\(w\\) (the window size) and \\(p\\) (the sampling factor) affect how  the  value is computed, but \\(\\pi\\) is fairly robust to these values as described in the preprint of Lipt\u00e1k et al.<sup>1</sup>.</p>"},{"location":"#how-pipfp-rs-works","title":"How <code>pipfp-rs</code> works","text":"<p>The usage for <code>pipfp-rs</code> is shown below.  It has one required parameter (<code>-i</code>/<code>--input</code>) which takes either the path to a directory, or a file that lists a collection of input files (1 file per line). If it is provided with a directory, it will walk the directory and collect all of the files ending in <code>.fa</code>, <code>.fa.gz</code>, <code>.fna</code> or <code>.fna.gz</code> (or the capital versions of these), it will then sort the  file names lexicographically, and process the sequences in that order. If a list of files is provided, the files will be processed in the order they are given.</p> <p>To process the input <code>pipfp-rs</code> will iterate through the files, and after parsing each, will compute the current value of \\(\\pi_{w,p}\\) --- the substring complexity measure for the current sequence collection.  These \\(\\pi\\) values will be stored and, at the end of the program, written as a <code>JSON</code> dictinary to <code>stdout</code>.</p>"},{"location":"#using-pipfp-rs","title":"Using <code>pipfp-rs</code>","text":"<p>The usage of <code>pipfp-rs</code> is as follows.</p> <pre><code>Usage: pipfp-rs [OPTIONS] --input &lt;INPUT&gt;\n\nOptions:\n  -i, --input &lt;INPUT&gt;      Either a directory containing FASTA files, or a file with a list of (FASTA) file paths\n  -w &lt;W&gt;                   window size [default: 10]\n  -p &lt;P&gt;                   sparsity [default: 100]\n  -t, --threads &lt;THREADS&gt;  Number of threads [default: all]\n  -n, --normalized         write out normalized \u03c0 values\n  -h, --help               Print help\n  -V, --version            Print version\n</code></pre> <p>The <code>-i</code> parameter is the only required input.  The <code>-w</code> and <code>-p</code> parameters control the window size and sparsity factor, as describe in the pipfp preprint<sup>1</sup>. The  <code>-t</code> parameter allows for multi-threaded comptuation of the \\(pi\\) values, and can speed up execution if the input sequences are large or there are many.  Finally, the <code>-n</code> flag will write out the \\(pi\\) values in normalized form (i.e. so that the largest value at the end of the array is 1.0).</p> <p>The output will be written to <code>stdout</code>, and consists of a <code>JSON</code> dictionary with a key <code>pis</code> whose corresponding value is an array of the compute \\(\\pi\\) values and  a key <code>norm</code> whose value is <code>true</code> if the <code>-n</code> flag was used and <code>false</code> otherwise.</p>"},{"location":"#references","title":"References","text":"<ol> <li> <p>Zsuzsanna Lipt\u00e1k, Simone Luc\u00e0, Francesco Masillo bioRxiv 2025.02.21.639270; doi: https://doi.org/10.1101/2025.02.21.639270 \u21a9\u21a9</p> </li> <li> <p>pipfp \u21a9</p> </li> </ol>"}]}